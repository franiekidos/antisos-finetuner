#!/usr/bin/env python3
#
# Antisos Performance Manager - Polished and Robust Implementation
# Includes centralized GPU optimization logic and improved error handling for system changes.
#
import gi
# Explicitly require versions to avoid issues
try:
    gi.require_version('Gtk', '4.0')
    gi.require_version('Adw', '1')
except ValueError as e:
    print(f"Error requiring Gtk/Adw versions: {e}")
    sys.exit(1)
    
from gi.repository import Gtk, Adw, GLib, Gdk, Gio
import os
import subprocess
import sys
import threading
import time
import psutil
import random

# --- Profiles ---
PROFILES = {
    'render': {
        'name': 'Code/Render',
        'desc': 'Prioritizes stable CPU speed and high I/O throughput for compilation and rendering tasks.',
        'icon': 'cpu-symbolic',
        'freq_range': (4.5, 4.9),
        'temp_range': (55, 65),
        'load_range': (75, 85),
        'gpu_load_range': (40, 70), 
        'scheduler': 'bfq',
        'governor': 'performance',
        'gpu_profile': 'auto' # Balanced GPU profile (Adaptive/Auto)
    },
    'gaming': {
        'name': 'Gaming Mode',
        'desc': 'Maximizes CPU and GPU performance for low-latency gaming.',
        'icon': 'joystick-symbolic',
        'freq_range': (4.8, 5.2),
        'temp_range': (65, 75),
        'load_range': (85, 95),
        'gpu_load_range': (70, 99), 
        'scheduler': 'mq-deadline', 
        'governor': 'performance',
        'gpu_profile': 'high' # Maximum GPU performance (Prefer Maximum Performance)
    },
    'powersaver': {
        'name': 'Power Saver',
        'desc': 'Reduces CPU frequency and power consumption to extend battery life during light use.',
        'icon': 'battery-symbolic',
        'freq_range': (1.0, 2.0),
        'temp_range': (35, 45),
        'load_range': (10, 30),
        'gpu_load_range': (5, 20), 
        'scheduler': 'mq-deadline',
        'governor': 'powersave',
        'gpu_profile': 'low' # Minimum power usage for the GPU (Power Save/Adaptive)
    }
}

class MetricCard(Gtk.Box):
    def __init__(self, icon_name, label_text, initial_value, css_class):
        super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        self.set_css_classes(['card', css_class])
        self.set_vexpand(True)
        self.set_size_request(120, 80)

        icon = Gtk.Image.new_from_icon_name(icon_name)
        icon.set_pixel_size(24)
        icon.set_halign(Gtk.Align.START)

        label = Gtk.Label(label=label_text, halign=Gtk.Align.START, css_classes=['caption', 'dim-label'])
        self.value_label = Gtk.Label(label=initial_value, halign=Gtk.Align.START)
        self.value_label.set_css_classes(['title-4', 'bold'])

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        vbox.append(label)
        vbox.append(self.value_label)
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        hbox.append(icon)
        hbox.append(vbox)
        self.set_margin_start(10)
        self.set_margin_end(10)
        self.set_margin_top(10)
        self.set_margin_bottom(10)
        self.append(hbox)

    def update_value(self, value):
        self.value_label.set_label(value)

class AppWindow(Adw.ApplicationWindow):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.set_title("Antisos Performance Manager")
        self.set_default_size(800, 600)

        self.active_profile = 'powersaver'
        self.monitoring_running = False
        self.monitoring_thread = None
        self.metrics = {}

        self._build_ui()
        self._apply_css()
        self._initialize_metrics_widgets()
        self.set_profile(self.active_profile)

    def _apply_css(self):
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(
            b"""
            .sidebar-bg { background-color: @theme_bg_color; }
            .main-content-bg { background-color: @theme_base_color; }
            .card { background-color: @theme_bg_color; border-radius: 12px; padding: 10px; }
            .profile-card { padding: 15px; border-radius: 12px; border: 2px solid transparent; margin-bottom: 12px; }
            .profile-card:hover { background-color: @theme_base_color; }
            .active-profile { background-color: @accent_bg_color; border-color: @accent_color; }
            .metric-bg { background-color: #1a1a1a; }
            """
        )
        # Use Gdk.Display.get_default() for Gtk4 style context
        Gtk.StyleContext.add_provider_for_display(Gdk.Display.get_default(), css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

    def _build_ui(self):
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.set_content(main_box)

        content_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)

        # 1. Sidebar (Profile Selector)
        self.profile_list = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.profile_list.set_margin_top(20)
        self.profile_list.set_margin_bottom(20)
        self.profile_list.set_margin_start(15)
        self.profile_list.set_margin_end(15)
        for p_id, data in PROFILES.items():
            self._create_profile_card(p_id, data)

        sidebar_scrolled = Gtk.ScrolledWindow()
        sidebar_scrolled.set_child(self.profile_list)
        sidebar_scrolled.set_size_request(250, -1)
        sidebar_scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        content_box.append(sidebar_scrolled)

        # 2. Main content (Advanced Settings)
        self.settings_stack = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.settings_stack.set_css_classes(['main-content-bg'])

        pref_page = Adw.PreferencesPage()
        config_group = Adw.PreferencesGroup(title="Advanced Configuration", description="Fine-tune system behavior.")

        row_max_cpu = Adw.ActionRow(title="Force Maximum CPU Frequency", subtitle="Locks CPU at maximum speed regardless of profile.")
        switch_max_cpu = Gtk.Switch(valign=Gtk.Align.CENTER)
        row_max_cpu.add_suffix(switch_max_cpu)
        row_max_cpu.set_activatable_widget(switch_max_cpu)
        config_group.add(row_max_cpu)

        row_low_latency = Adw.ActionRow(title="Enable Low-Latency Audio", subtitle="Optimizes audio buffers for real-time work.")
        switch_low_latency = Gtk.Switch(valign=Gtk.Align.CENTER)
        row_low_latency.add_suffix(switch_low_latency)
        row_low_latency.set_activatable_widget(switch_low_latency)
        config_group.add(row_low_latency)

        row_vram = Adw.ActionRow(title="VRAM Allocation Limit", subtitle="Set max memory for integrated GPU (MB).")
        vram_combo = Gtk.DropDown.new_from_strings(["512 MB", "1024 MB", "2048 MB"])
        vram_combo.set_selected(1)
        row_vram.add_suffix(vram_combo)
        config_group.add(row_vram)

        pref_page.add(config_group)
        self.settings_stack.append(pref_page)
        content_box.append(self.settings_stack)
        content_box.set_hexpand(True)
        main_box.append(content_box)

        # 3. Live monitor footer
        self.metrics_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        self.metrics_box.set_css_classes(['metric-bg'])
        self.metrics_box.set_size_request(-1, 100)
        self.metrics_box.set_homogeneous(True) 
        main_box.append(self.metrics_box)

    def _create_profile_card(self, p_id, data):
        card_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        card_box.set_css_classes(['profile-card'])
        card_box.set_halign(Gtk.Align.FILL)

        icon = Gtk.Image.new_from_icon_name(data['icon'])
        icon.set_pixel_size(32)
        icon.set_margin_end(15)
        card_box.append(icon)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        vbox.append(Gtk.Label(label=data['name'], halign=Gtk.Align.START, css_classes=['title-4', 'bold']))
        vbox.append(Gtk.Label(label=data['desc'], halign=Gtk.Align.START, wrap=True, css_classes=['caption']))
        card_box.append(vbox)

        click = Gtk.GestureClick.new()
        click.connect("released", self._on_profile_clicked, p_id, card_box)
        card_box.add_controller(click)

        setattr(self, f"card_{p_id}", card_box)
        self.profile_list.append(card_box)

    def _initialize_metrics_widgets(self):
        self.metrics['cpuFreq'] = MetricCard("preferences-system-symbolic", "CPU Frequency", "0.0 GHz", "freq-card")
        self.metrics['cpuLoad'] = MetricCard("network-server-symbolic", "CPU Load", "0%", "load-card")
        self.metrics['gpuTemp'] = MetricCard("temperature-symbolic", "Temp (Avg)", "0°C", "temp-card") 
        self.metrics['gpuLoad'] = MetricCard("video-display-symbolic", "GPU Load", "0%", "gpuload-card") 
        self.metrics['ioScheduler'] = MetricCard("media-optical-symbolic", "I/O Scheduler", "none", "scheduler-card")
        
        for card in self.metrics.values():
            self.metrics_box.append(card)

    def _on_profile_clicked(self, gesture, n_press, x, y, p_id, card_box):
        if self.active_profile == p_id:
            return
        print(f"Switching to profile: {p_id}")
        self.set_profile(p_id)

    def _apply_gpu_profile(self, gpu_profile):
        """Applies GPU performance level based on vendor detection."""
        
        # --- AMD GPU Logic (via sysfs) ---
        amd_path = '/sys/class/drm/card0/device/power_dpm_force_performance_level'
        
        # Mapping GPU profile to sysfs values
        if gpu_profile == 'high':
            amd_value = 'high'
        elif gpu_profile == 'low':
            amd_value = 'low'
        else: # 'auto' or default
            amd_value = 'auto'

        if os.path.exists(amd_path):
            try:
                with open(amd_path, 'w') as f:
                    f.write(amd_value)
                print(f"Applied AMD GPU profile: {amd_value}")
                return True
            except PermissionError:
                raise # Re-raise to be caught by the main try block
            except Exception as e:
                print(f"Error applying AMD GPU profile: {e}")
                return False

        # --- NVIDIA GPU Logic (via nvidia-settings CLI) ---
        # PowerMizerMode: 1=Prefer Maximum Performance, 2=Adaptive, 3=Auto
        if gpu_profile == 'high':
            nv_mode = 1 # Prefer Maximum Performance
        elif gpu_profile == 'low':
            nv_mode = 2 # Adaptive (Tries to use lowest P-state)
        else: # 'auto'
            nv_mode = 2 # Adaptive/Auto
            
        try:
            # Check if nvidia-settings is available (less prone to permission errors here)
            # FIX: Removed 'capture_output=True' to resolve conflict with explicit stdout/stderr redirection.
            subprocess.run(['nvidia-settings', '-q', 'GPUCoreTemp', '-t'], 
                           check=False, timeout=1, 
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Run the command to set the PowerMizer mode
            subprocess.run(['nvidia-settings', '-a', f'[gpu:0]/GpuPowerMizerMode={nv_mode}'], check=False)
            print(f"Attempted to set NVIDIA GpuPowerMizerMode={nv_mode} (Profile: {gpu_profile})")
            return True
        except FileNotFoundError:
            # nvidia-settings not installed or found
            pass
        except Exception as e:
            # Catching generic error during settings execution
            print(f"NVIDIA optimization command failed: {e}")
            return False
            
        return False # No compatible GPU detected or setting applied

    def set_profile(self, new_profile_id):
        # Update UI
        for p_id in PROFILES:
            card = getattr(self, f"card_{p_id}")
            if p_id == new_profile_id:
                card.add_css_class('active-profile')
            else:
                card.remove_css_class('active-profile')

        profile_data = PROFILES[new_profile_id]
        scheduler = profile_data['scheduler']
        governor = profile_data['governor']
        gpu_profile = profile_data['gpu_profile']

        print(f"Applying CPU Governor: {governor}, Scheduler: {scheduler}, GPU Profile: {gpu_profile}")

        # === REAL SYSTEM CHANGES (requires root/sudo for execution) ===
        try:
            # 1. CPU Governor
            for i in range(os.cpu_count()):
                path = f"/sys/devices/system/cpu/cpu{i}/cpufreq/scaling_governor"
                if os.path.exists(path):
                    with open(path, 'w') as f:
                        f.write(governor)

            # 2. I/O Scheduler
            valid_schedulers = ['mq-deadline', 'bfq', 'kyber', 'none']
            if scheduler not in valid_schedulers:
                scheduler = 'mq-deadline' # Fallback to a safe scheduler

            for dev in os.listdir('/sys/block'):
                # Check for common block devices (avoid loop devices, etc.)
                if dev.startswith(('sd', 'nvme', 'vd', 'mmcblk')): 
                    path = f"/sys/block/{dev}/queue/scheduler"
                    if os.path.exists(path):
                        with open(path, 'w') as f:
                            f.write(scheduler)

            # 3. GPU OPTIMIZATION 
            self._apply_gpu_profile(gpu_profile)

        except PermissionError:
            # This clear message tells the user why the application isn't working on system files
            print("\n===========================================================")
            print("!!! PERMISSION DENIED !!!")
            print("You must run Antisos Performance Manager with elevated privileges (sudo) to apply system changes.")
            print("Changes were blocked. Metrics will continue to mock data or read non-priviledged values.")
            print("===========================================================\n")
        except Exception as e:
            print(f"Critical error during system configuration: {e}")

        self.active_profile = new_profile_id

        # Restart monitoring
        if self.monitoring_thread and self.monitoring_thread.is_alive():
            self.monitoring_running = False
            # Wait for the thread to finish cleanly
            self.monitoring_thread.join(timeout=2) 

        self.monitoring_running = True
        self.monitoring_thread = threading.Thread(target=self._monitor_system, daemon=True)
        self.monitoring_thread.start()

    def _monitor_system(self):
        while self.monitoring_running:
            cpu_freq = cpu_temp = cpu_load = gpu_load = 0.0
            scheduler = "unknown"
            
            # Flag to track if we successfully read any real metric (CPU load is usually readable)
            use_mock_data = True 

            try:
                # 1. CPU Frequency (Average)
                freqs = psutil.cpu_freq(percpu=True)
                if freqs:
                    # Current frequency is in MHz, convert to GHz
                    cpu_freq = sum(f.current for f in freqs) / len(freqs) / 1000
                    use_mock_data = False 

                # 2. Temperatures (Best effort read)
                temps = psutil.sensors_temperatures()
                temp_sources = ['coretemp', 'k10temp', 'acpitz']
                for source in temp_sources:
                    if source in temps and temps[source]:
                        cpu_temp = temps[source][0].current
                        break # Found a valid temp sensor

                # 3. CPU Load (Load average normalized by CPU count)
                cpu_load = psutil.getloadavg()[0] / psutil.cpu_count() * 100

                # 4. GPU Load (Blueprint: Try sysfs or nvidia-smi)
                gpu_load_success = False
                try:
                    # Common path for integrated GPU busy percentage (Intel/AMD)
                    with open('/sys/class/drm/card0/device/gpu_busy_percent', 'r') as f:
                        gpu_load = float(f.read().strip())
                        gpu_load_success = True
                except (FileNotFoundError, IndexError, ValueError):
                    # Try reading NVIDIA/other GPU through command
                    try:
                        result = subprocess.run(
                            ['nvidia-smi', '--query-gpu=utilization.gpu', '--format=csv,noheader,nounits'], 
                            capture_output=True, text=True, check=True, timeout=1
                        )
                        gpu_load = float(result.stdout.strip().split('\n')[0])
                        gpu_load_success = True
                    except Exception:
                        pass # Failed to read GPU load

                # 5. I/O Scheduler (Read currently applied scheduler)
                for dev in os.listdir('/sys/block'):
                    if dev.startswith(('sd', 'nvme', 'vd', 'mmcblk')):
                        path = f"/sys/block/{dev}/queue/scheduler"
                        if os.path.exists(path):
                            with open(path) as f:
                                line = f.read().strip()
                                # Extracts the name inside the brackets, or the first word
                                if '[' in line and ']' in line:
                                    scheduler = line.split('[')[1].split(']')[0]
                                else:
                                    scheduler = line.split()[0]
                                break
            
            except Exception:
                # Catch unexpected OS errors during monitoring (e.g., /sys files disappearing)
                # If any real read failed, we might use mock data, but we proceed anyway
                pass


            if use_mock_data:
                # Use mock data defined by the active profile
                profile_data = PROFILES[self.active_profile]
                cpu_freq = round(random.uniform(*profile_data['freq_range']), 1)
                cpu_temp = random.randint(*profile_data['temp_range'])
                cpu_load = random.randint(*profile_data['load_range'])
                gpu_load = random.randint(*profile_data['gpu_load_range']) 
                scheduler = profile_data['scheduler']
                
            # Pass all 5 metrics to the UI update function
            GLib.idle_add(self._update_ui_metrics, cpu_freq, cpu_temp, cpu_load, gpu_load, scheduler)
            time.sleep(1.5)

    def _update_ui_metrics(self, cpu_freq, cpu_temp, cpu_load, gpu_load, scheduler):
        """Updates the MetricCard widgets."""
        self.metrics['cpuFreq'].update_value(f"{cpu_freq:.1f} GHz")
        self.metrics['gpuTemp'].update_value(f"{cpu_temp}°C")
        self.metrics['cpuLoad'].update_value(f"{cpu_load:.0f}%")
        self.metrics['gpuLoad'].update_value(f"{gpu_load:.0f}%")
        self.metrics['ioScheduler'].update_value(scheduler.upper())
        return GLib.SOURCE_REMOVE

class AntisosApp(Adw.Application):
    def __init__(self):
        super().__init__(application_id="com.antisos.PerformanceManager",
                         flags=Gio.ApplicationFlags.DEFAULT_FLAGS)

    def do_activate(self):
        win = self.props.active_window
        if not win:
            win = AppWindow(application=self)
        win.present()

if __name__ == "__main__":
    # Fix D-Bus warning in live environment
    os.environ['NO_AT_BRIDGE'] = '1'
    app = AntisosApp()
    app.run(sys.argv)